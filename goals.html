<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="styles.css">
    <title>Gyoji Programming Language</title>
</head>
<body>

<div class="sidenav">
  <h1><a href="index.html">About</a></h1>
  <h1><a href="examples.html">Examples</a></h1>
  <h1><a href="https://github.com/jarney/gyoji">Source Code</a></h1>
  <h1><a href="architecture.html">Architecture</a></h1>
  <h1><a href="help-wanted.html">Help Wanted</a></h1>
  <h1><a href="goals.html">Goals</a></h1>
  <h1><a href="doxygen.html">Doxygen</a></h1>
  <h1><a href="code-coverage.html">Code Coverage</a></h1>
  <h1><a href="support.html">Support</a></h1>
</div>

<div class="main">
  <h1>Gyoji Programming Language</h1>
<h2>Goals</h3>
<p>
  I would like to have a type-safe and memory safe version of C.
  This means a lot of different things to different people, so a bit of explanation is required.
  Complete memory safety is a myth.  Although it's true that languages like Rust provide
  semantics in &#39;safe&#39; mode which allow the memory to be &#39;memory safe&#39;, they do so at the cost
  of a difficult mental model, the borrow checker.  While the borrow-checker and region-style
  semantic reasoning does provide assurances of safety, they come at the cost of
  understandability of the model that restricts some legitimate use-cases which are
  perfectly memory safe, but if the compiler can't prove it, they are disallowed.
</p>
<p>
  Rust cannot prove many common cases, and it might be argued that a better
  reasoning system might someday hope to prove that all memory safe
  code is, in fact, safe.  This cannot happen, however, because Rice's theorem,
  a consequence of Turing's Stopping theorem, show that compilers cannot,
  in general, prove all cases[1].
</p>

<p>
  The other problem that Rust has is that is's suffering from bloat.  The
  executables end up being very large because the compiler and the core
  libraries are tightly coupled.  The whole &#39;panic&#39; and unwinding system
  is built-in and comes along with a bunch of garbage that isn't always (usually)
  wanted or needed.  You could argue that it's fine because you can
  always #![no_std] and #[no_panic] stuff away, but the fact that it's there
  by default is a bit troubling.  This is particularly true when
  functions like &#39;sqrt()&#39; may panic and unless the programmer knows
  to protect against this, can be a big problem for reliability.  The
  authors of Rust would argue that it's better to panic() rathre than
  have undefined behaviour, but the fact that &#39;sqrt()&#39; on a negative
  number may be undefined in a mathematical sense, it need not be
  undefined in a computational sense.  Returning a NaN would seem
  to be a better choice than a panic() in these cases, but making
  philosophical changes to the core standard library at this stage
  are tall asks.
</p>
<p>
  Instead, this language follows a different path.  Minimalism.  We aim
  for a C/Java/C++ style syntax with support for objects,
  but without a lot of the things that come with them.  References and
  borrow checking for memory safety.  Classes and basic notions of
  inheritance, but without allowing multiple inheritance and
  the ambiguities associated.  Interfaces may be multiply inherited, but
  the vtable is constructed associated with the interface, not as a part of
  the class.  Constructors cannot leak their content before initialization,
  removing the problem of &#39;half-initialized&#39; objects.  Generics are Java-style
  with type erasure which removes a lot of the complexity and bloat of C++-style
  template metaprogramming.  The goal is to unify the best features
  of languages that have come before and to do it in the simplest way possible.
</p>


<h3>Guarantees we want the language to make</h3>
<p>
  We would like the language to make certain guarantees about
  code that it compiles.
</p>
<h4>Initialization before use</h4>
<p>
  Code that compiles outside of "unsafe" blocks guarantees
  that every variable is assigned to some initial value
  before it is used.  Use, in this context includes use
  in an expression to calculate a value (i.e. an rvalue)
  and also includes expressions that de-reference pointers
  and even take the address of values.
</p>
<p>
  For local function-scope variables, this guarantee is
  enforced by some rules:
  <ul>
    <li>After a primitive value is declared, it must first be assigned a value
      before it is used in any expression.
    </li>
    <li>After a class value is declared, it must call a constructor before it is used.</li>
    <li>Every constructor must initialize every primitive member to some initial value.</li>
    <li>Every constructor must call the constructor of every class member</li>
  </ul>
</p>
<p>
  Note that under this definition, it is not allowed to take a pointer
  or reference to a variable and perform the initialization THROUGH that
  pointer or reference.  While this would constitute an initialization before
  use, the complexity of this form of initialization is sufficient
  to make the validation of the rule extremely time consuming.  Therefore,
  Gyoji has taken the decision to disallow this form of initialization
  in its validation.
</p>
  
<h4>Scope Guards</h4>
<p>
  Classes declared in a local scope will always call their corresponding
  destructor at the end of the lexical scope in which it was declared.
</p>
<p>
  This guarantee extends to the use of 'goto' and 'break' statements
  where scope is exited by means other than the '}' at the end of
  the lexical scope.  That is, if you 'goto' a block which no longer
  includes a variable, the destructor will be called when the scope
  is left during execution.
</p>

<h4>Exceptions</h4>
<p>
  Code compiled by Gyoji will not ORIGINATE any exceptions which
  would break control-flow.  Note that this does NOT mean that
  exceptions are not possible.  Exceptions may still originate
  from C or C++ code called indirectly by Gyoji and care must
  be taken that the functions called do not raise exceptions.
</p>
  </body>
</html>
